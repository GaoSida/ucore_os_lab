# Lab 1 Report
计35 高思达 2013011413

gsd13@mails.tsinghua.edu.cn

## 练习一
#####0、本练习中涉及到的原理课中的知识点
本练习主要是熟悉makefile的写法。主要涉及的原理的启动部分，特别是关于bootloader的内容。
通过研读makefile，我们可以更细致地了解原理课中所讲的磁盘中存储的内容的分布，即主引导扇区（装有bootloader），和操作系统内核的存放位置与相互关系。

此外，也通过观察make时使用的文件，对于操作系统中的组成模块有了一个总览，这也呼应了原理课中的内容。

#####1、操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)

（1）生成ucore.img之前的准备工作

* makefile中include了```tools/functions.mk```文件，这个文件中定义了一些可供调用的“函数”，其中的“函数实现”是一些命令行命令。
* 同时，在文件的开始定义了一些“宏变量”。这些定义应当都是为了简化makefile的编写，增加可读性。这些“宏定义”都需要使用```$(变量名)```的形式来访问。直接阅读makefile进行宏展开是困难的，一个简单的办法是使用```make V=```命令，直接看展开后的命令。
* 生成镜像之前，首先要生成kernel和bootblock两个模块，其中bootblock还需要先生成sign。下面逐一解释这些模块的准备过程。

（2）生成kernel

* 首先，定义了```KINCLUDE, KSRCDIR```等文件路径列表，用于后续引用的方便。
* 然后使用该命令：

```
$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))
```
通过层层宏展开，找到前述目录中的```.c, .S```文件，批量生成编译命令。其中，文件类型是通过变量```CTYPE	:= c S```来指定的。找到文件之后，使用```gcc```把这些文件编译成```.o```文件。之前定义的```KCFLADS```变量给目录加上了```-I```前缀，即成为了其中的几个编译选项。

以```init.o```为例，其展开后的编译命令为：（为了方便阅读，makefile中使用反斜线标志换行）

```
gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  \
    -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/     \
    -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c                   \
    -o obj/kern/init/init.o
```

其中需要关注的编译选项的含义有：
    
    -fno-builtin: 除非用__builtin_前缀，否则不进行builtin函数的优化； 
    -ggdb: 生成可供gdb使用的调试信息，否则无法使用qemu+gdb进行调试；
    -m32: 面向32位机器生成代码。因为我们的模拟器是32位的；
    -gstabs: 生成stabs格式的调试信息，使得ucore的monitor可以显示出函数调用栈信息；
    -nostdinc: 不使用标准库。ucore作为内核，当然如此；
    -fno-stack-protector: 不生成用于检测缓冲区溢出的代码，同样是因为ucore不是应用程序；
    -I<dir>: 添加搜索头文件的路径；

* 然后进行生成编译目标。这条命令通过展开，把目标指定为目录```BINDIR := bin```下，文件名为```kernel```的可执行文件。

```
kernel = $(call totarget,kernel)
```

* 使用这条命令，链接已经编译好的```.o```文件。链接脚本```tools/kernel.ld```由```-T```参数指定。这条命令也使用了很多宏展开，得到文件的列表，和链接选项的列表。

```
$(kernel): tools/kernel.ld

$(kernel): $(KOBJS)
	@echo + ld $@
	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)
	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel)

$(call create_target,kernel)
```

（3）生成bootblock

* 同样，首先编译相关的```.c, .S```文件。使用的命令如下：

```
bootfiles = $(call listf_cc,boot)
$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(HOSTCC),$(CFLAGS) -Os -nostdinc))
```

由此，产生了编译生成```bootasm.o, bootmain.o```的命令，其过程和形式都和kernel类似。值得注意的是，两个文件的编译过程中都使用了```-Os```选项，表示编译时为减小代码大小进行优化。由于主引导扇区的大小有512字节的限制，我们的bootloader代码不能大于510字节（因为最后两字节的内容是固定的，详见第2问），所以必须加上该选项的限制。

* 生成bootblock时，也依赖sign工具的生成，后者的命令如下。从```.c```生成```.o```，并进一步生成可执行文件。这个工具为bootloader在512字节中的最后两个字节打上0x55AA的签名。

```
$(call add_files_host,tools/sign.c,sign,sign)
$(call create_target_host,sign,sign)
```

* 直接生成bootblock的命令为：

```
bootblock = $(call totarget,bootblock)

$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
	@echo + ld $@
	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)
	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)

$(call create_target,bootblock)
```

同样先生成了目标文件目录。下面分别解释后几条命令展开后的含义。

* 生成```bootblock.o```

```
ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 \
obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o
```

其中的参数含义为：

    -m elf_i386: 指定模拟为i386上的连接器；
    -N: 表示代码段和数据段均可读可写，且关闭数据段页对齐；
    -e start: 指定入口为entry；
    -Ttext 0x7C00: 制定代码段开始位置为0x7C00；

* 拷贝二进制代码```bootblock.o```到```bootblock.out```

```
objcopy -S -O binary obj/bootblock.o obj/bootblock.out
```

其中参数含义为：
       
    -S  移除所有符号和重定位信息
    -O binary 指定输出格式为二进制文件

* 使用sign工具设置签名，生成可用的bootblock:

```
bin/sign obj/bootblock.out bin/bootblock
```

（4）生成```ucore.img```文件

* 指定生成文件的路径：```UCOREIMG	:= $(call totarget,ucore.img)```
* 生成文件的makefile命令：

```
$(UCOREIMG): $(kernel) $(bootblock)
	$(V)dd if=/dev/zero of=$@ count=10000
	$(V)dd if=$(bootblock) of=$@ conv=notrunc
	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc

$(call create_target,ucore.img)
```

其展开后为三条```dd```命令，在Linux中意为copy/convert file。

```
dd if=/dev/zero of=bin/ucore.img count=10000
```
上面这条命令在文件中写10000个全0的512字节的块。

```
dd if=bin/bootblock of=bin/ucore.img conv=notrunc
```
上面这条命令把```bootblock```写入```ucore.img```的第一个块。

```
dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc
```
上面这条命令从```ucore.img```的第二个块开始写入```kernel```。


#####2、一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？
根据```sign.c```的实现，系统对这一512字节的主引导扇区的要求是：

```
第510字节为：0x55
第511字节为：0xAA
```

其中隐含的要求是bootloader的大小不能超过510字节。但是，系统眼中前512字节就是二进制串，无论其中的bootloader代码是不是完整的，系统眼里都是合法的。但显然，当bootloader超过510字节的时候会出问题，这一检查交给sign.c去做了。

##练习二
#####0、本练习中涉及到的原理课中的知识点

##练习三
#####0、本练习中涉及到的原理课中的知识点

##练习四
#####0、本练习中涉及到的原理课中的知识点

##练习五
#####0、本练习中涉及到的原理课中的知识点

##练习六
#####0、本练习中涉及到的原理课中的知识点

