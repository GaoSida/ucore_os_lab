# Lab 1 Report
计35 高思达 2013011413

gsd13@mails.tsinghua.edu.cn

## 练习一
#####0、本练习中涉及到的原理课中的知识点
本练习主要是熟悉makefile的写法。主要涉及的原理的启动部分，特别是关于bootloader的内容。
通过研读makefile，我们可以更细致地了解原理课中所讲的磁盘中存储的内容的分布，即主引导扇区（装有bootloader），和操作系统内核的存放位置与相互关系。

此外，也通过观察make时使用的文件，对于操作系统中的组成模块有了一个总览，这也呼应了原理课中的内容。

#####1、操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)

（1）生成ucore.img之前的准备工作

* makefile中include了```tools/functions.mk```文件，这个文件中定义了一些可供调用的“函数”，其中的“函数实现”是一些命令行命令。
* 同时，在文件的开始定义了一些“宏变量”。这些定义应当都是为了简化makefile的编写，增加可读性。这些“宏定义”都需要使用```$(变量名)```的形式来访问。直接阅读makefile进行宏展开是困难的，一个简单的办法是使用```make V=```命令，直接看展开后的命令。
* 生成镜像之前，首先要生成kernel和bootblock两个模块，其中bootblock还需要先生成sign。下面逐一解释这些模块的准备过程。

（2）生成kernel

* 首先，定义了```KINCLUDE, KSRCDIR```等文件路径列表，用于后续引用的方便。
* 然后使用该命令：

```
$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))
```
通过层层宏展开，找到前述目录中的```.c, .S```文件，批量生成编译命令。其中，文件类型是通过变量```CTYPE	:= c S```来指定的。找到文件之后，使用```gcc```把这些文件编译成```.o```文件。之前定义的```KCFLADS```变量给目录加上了```-I```前缀，即成为了其中的几个编译选项。

以```init.o```为例，其展开后的编译命令为：（为了方便阅读，makefile中使用反斜线标志换行）

```
gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  \
    -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/     \
    -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c                   \
    -o obj/kern/init/init.o
```

其中需要关注的编译选项的含义有：
    
    -fno-builtin: 除非用__builtin_前缀，否则不进行builtin函数的优化； 
    -ggdb: 生成可供gdb使用的调试信息，否则无法使用qemu+gdb进行调试；
    -m32: 面向32位机器生成代码。因为我们的模拟器是32位的；
    -gstabs: 生成stabs格式的调试信息，使得ucore的monitor可以显示出函数调用栈信息；
    -nostdinc: 不使用标准库。ucore作为内核，当然如此；
    -fno-stack-protector: 不生成用于检测缓冲区溢出的代码，同样是因为ucore不是应用程序；
    -I<dir>: 添加搜索头文件的路径；

* 然后进行生成编译目标。这条命令通过展开，把目标指定为目录```BINDIR := bin```下，文件名为```kernel```的可执行文件。

```
kernel = $(call totarget,kernel)
```

* 使用这条命令，链接已经编译好的```.o```文件。链接脚本```tools/kernel.ld```由```-T```参数指定。这条命令也使用了很多宏展开，得到文件的列表，和链接选项的列表。

```
$(kernel): tools/kernel.ld

$(kernel): $(KOBJS)
	@echo + ld $@
	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)
	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel)

$(call create_target,kernel)
```

（3）生成bootblock

* 同样，首先编译相关的```.c, .S```文件。使用的命令如下：

```
bootfiles = $(call listf_cc,boot)
$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(HOSTCC),$(CFLAGS) -Os -nostdinc))
```

由此，产生了编译生成```bootasm.o, bootmain.o```的命令，其过程和形式都和kernel类似。值得注意的是，两个文件的编译过程中都使用了```-Os```选项，表示编译时为减小代码大小进行优化。由于主引导扇区的大小有512字节的限制，我们的bootloader代码不能大于510字节（因为最后两字节的内容是固定的，详见第2问），所以必须加上该选项的限制。

* 生成bootblock时，也依赖sign工具的生成，后者的命令如下。从```.c```生成```.o```，并进一步生成可执行文件。这个工具为bootloader在512字节中的最后两个字节打上0x55AA的签名。

```
$(call add_files_host,tools/sign.c,sign,sign)
$(call create_target_host,sign,sign)
```

* 直接生成bootblock的命令为：

```
bootblock = $(call totarget,bootblock)

$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
	@echo + ld $@
	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)
	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)

$(call create_target,bootblock)
```

同样先生成了目标文件目录。下面分别解释后几条命令展开后的含义。

* 生成```bootblock.o```

```
ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 \
obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o
```

其中的参数含义为：

    -m elf_i386: 指定模拟为i386上的连接器；
    -N: 表示代码段和数据段均可读可写，且关闭数据段页对齐；
    -e start: 指定入口为entry；
    -Ttext 0x7C00: 制定代码段开始位置为0x7C00；

* 拷贝二进制代码```bootblock.o```到```bootblock.out```

```
objcopy -S -O binary obj/bootblock.o obj/bootblock.out
```

其中参数含义为：
       
    -S  移除所有符号和重定位信息
    -O binary 指定输出格式为二进制文件

* 使用sign工具设置签名，生成可用的bootblock:

```
bin/sign obj/bootblock.out bin/bootblock
```

（4）生成```ucore.img```文件

* 指定生成文件的路径：```UCOREIMG	:= $(call totarget,ucore.img)```
* 生成文件的makefile命令：

```
$(UCOREIMG): $(kernel) $(bootblock)
	$(V)dd if=/dev/zero of=$@ count=10000
	$(V)dd if=$(bootblock) of=$@ conv=notrunc
	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc

$(call create_target,ucore.img)
```

其展开后为三条```dd```命令，在Linux中意为copy/convert file。

```
dd if=/dev/zero of=bin/ucore.img count=10000
```
上面这条命令在文件中写10000个全0的512字节的块。

```
dd if=bin/bootblock of=bin/ucore.img conv=notrunc
```
上面这条命令把```bootblock```写入```ucore.img```的第一个块。

```
dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc
```
上面这条命令从```ucore.img```的第二个块开始写入```kernel```。


#####2、一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？
根据```sign.c```的实现，系统对这一512字节的主引导扇区的要求是：

```
第510字节为：0x55
第511字节为：0xAA
```

其中隐含的要求是bootloader的大小不能超过510字节。但是，系统眼中前512字节就是二进制串，无论其中的bootloader代码是不是完整的，系统眼里都是合法的。但显然，当bootloader超过510字节的时候会出问题，这一检查交给sign.c去做了。

##练习二
#####0、本练习中涉及到的原理课中的知识点
本练习涉及到了机器加电后的第一段程序，即BIOS的运行，以及转接权交道bootloader手中的过程。在观察这一过程的同时，也复习了实模式的寻址方式。

#####1、从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。
```make debug```命令使用的gdb调试命令在```tools/gdbinit```中写。
为了查看BIOS的运行，我们不加载任何程序，直接在16位模式下运行虚拟机即可。
原本的```tools/gdbinit```在设置断点后运行了```continue```，这样就跑过了BIOS，我们无法观察BIOS的运行了。因此，我们删去这条命令。最终，```tools/gdbinit```中保留以下内容即可：

```
set architecture i8086
target remote :1234
```

这是运行```make debug```，gdb在一开始就会接管。这时可以查看当前的地址和指令，通过```x /5i $pc```，得到的输出如下：

```
=> 0xfff0:      add    %al,(%bx,%si)
   0xfff2:      add    %al,(%bx,%si)
   0xfff4:      add    %al,(%bx,%si)
   0xfff6:      add    %al,(%bx,%si)
   0xfff8:      add    %al,(%bx,%si)
```

首先，这里的指令都是2字节的长度，说明我们的确运行在16位模式下。但我们知道BIOS的第一条指令是长跳转指令，这显然不是BIOS。里面的指令对应的机器码是```0x0000```。查询[附录](https://objectkuan.gitbooks.io/ucore-docs/content/lab1/lab1_5_appendix.html)可以看到实模式的寻址方式，这时```PC```并不直接是指令地址，实模式的寻址方式是```CS << 4 + PC```。因此，改用```x /5i 16*$cs+$pc```，就能看到正确的BIOS指令：

```
   0xffff0:	ljmp   $0xf000,$0xe05b
   0xffff5:	xor    %dh,0x322f
```

确实是一条长跳转指令。我们使用```si```单步执行一条，再次使用```x /5i 16*$cs+$pc```查看指令，就能看到BIOS的主体：

```
   0xfe05b:	cmpl   $0x0,%cs:0x65a4
   0xfe062:	jne    0xfd2b9
   0xfe066:	xor    %ax,%ax
   0xfe068:	mov    %ax,%ss
   0xfe06a:	mov    $0x7000,%esp
   0xfe070:	mov    $0xf3c4f,%edx
   0xfe076:	jmp    0xfd12a
   0xfe079:	push   %ebp
   0xfe07b:	push   %edi
   0xfe07d:	push   %esi
```

然而，过去汇编语言课程中使用gdb调试都是把PC当做指令地址的。这应该是因为那时运行在保护模式下，所谓PC是逻辑地址，直接看就行了。但这时在实模式下，就要手动拿寄存器的值算出物理地址查看指令。

#####2、在初始化位置0x7c00设置实地址断点,测试断点正常。
接着上一问的过程，我们首先使用```b *0x7c00```设置断点。
然后，使用```continue```一直运行到断点处停止。首先，通过```p $cs```可以看到此时CS的值是0。
于是，此时可以直接通过```x /10i $pc```查看当前的代码：

```
=> 0x7c00:	cli    
   0x7c01:	cld    
   0x7c02:	xor    %ax,%ax
   0x7c04:	mov    %ax,%ds
   0x7c06:	mov    %ax,%es
   0x7c08:	mov    %ax,%ss
   0x7c0a:	in     $0x64,%al
   0x7c0c:	test   $0x2,%al
   0x7c0e:	jne    0x7c0a
   0x7c10:	mov    $0xd1,%al
```

这段代码和bootasm.S是几乎一致的（仅仅跳转指令的形式有所不同，实质是一样的）。这时仍然运行在16位模式下，即依然是实模式。

#####3、从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和bootblock.asm进行比较。

根据实验手册，进入bootloader后，由于需要进行实模式和保护模式的转换，即我们需要运行在32位机器上。所以首先输入命令```set architecture i386```。为了避免重复输入，修改```gdbinit```文件如下：

```
set architecture i8086
target remote :1234
b *0x7c00
continue
x /2i $pc
set architecture i386
```

同时，在makefile中找到```debug```任务，在启动Qemu时增加选项```-d in_asm -D q.log```即该行变为：

```
$(V)$(QEMU) -d in_asm -D q.log -S -s -parallel stdio -hda $< -serial null &
```

这样就能在q.log中看到qemu执行的所有指令的汇编代码。可以直接和bootasm.S、bootblock.asm中的代码进行对比。发现最后一行代码```call bootmain```的地址是```0x7c4a```在此设置端点，于是可以在q.log中得到全部的汇编代码：

```
IN: 
0x00007c00:  cli    

----------------
IN: 
0x00007c01:  cld    
0x00007c02:  xor    %ax,%ax
0x00007c04:  mov    %ax,%ds
0x00007c06:  mov    %ax,%es
0x00007c08:  mov    %ax,%ss

----------------
IN: 
0x00007c0a:  in     $0x64,%al

----------------
IN: 
0x00007c0c:  test   $0x2,%al
0x00007c0e:  jne    0x7c0a

----------------
IN: 
0x00007c10:  mov    $0xd1,%al
0x00007c12:  out    %al,$0x64
0x00007c14:  in     $0x64,%al
0x00007c16:  test   $0x2,%al
0x00007c18:  jne    0x7c14

----------------
IN: 
0x00007c1a:  mov    $0xdf,%al
0x00007c1c:  out    %al,$0x60
0x00007c1e:  lgdtw  0x7c6c
0x00007c23:  mov    %cr0,%eax
0x00007c26:  or     $0x1,%eax
0x00007c2a:  mov    %eax,%cr0

----------------
IN: 
0x00007c2d:  ljmp   $0x8,$0x7c32

----------------
IN: 
0x00007c32:  mov    $0x10,%ax
0x00007c36:  mov    %eax,%ds

----------------
IN: 
0x00007c38:  mov    %eax,%es

----------------
IN: 
0x00007c3a:  mov    %eax,%fs
0x00007c3c:  mov    %eax,%gs
0x00007c3e:  mov    %eax,%ss

----------------
IN: 
0x00007c40:  mov    $0x0,%ebp

----------------
IN: 
0x00007c45:  mov    $0x7c00,%esp
0x00007c4a:  call   0x7cd1

```

这段代码和bootasm.S中的代码完全一致，只是填上了宏和函数跳转地址。但是和bootblock.asm略有不同，发生在地址```0x7c1e```到```0x7c25```，似乎是反汇编时的短句不同，bootblock.asm中产生了更多、更短的指令，推测是反汇编时的问题（对于相同机器代码的指令理解不一致）。

#####4、自己找一个bootloader或内核中的代码位置，设置断点并进行测试。

这里通过实践简单学习gdb的使用方法。在```0x7c00```处，使用```p $eax```查看寄存器eax的值为```$1 = 43605```，在```xorw %ax, %ax```后设置端点，即```b *0x7c04```，再次查看这里的值，发现eax被成功清零了。


##练习三
#####0、本练习中涉及到的原理课中的知识点
原理课中介绍了bootloader大致需要做些什么事情，本练习通过阅读代码明确其中的细节。
主要包括开启A20，设置GDT，转到保护模式三个主要步骤。

#####1、请分析bootloader是如何完成从实模式进入保护模式的。
bootloader的一开始是```$CS=0, $PC=0x7c00```，由这里进入程序。首先进行初始化，即做关中断等操作，并把关键的段寄存器设为0。

```
    cli                                             # Disable interrupts
    cld                                             # String operations increment

    # Set up the important data segment registers (DS, ES, SS).
    xorw %ax, %ax                                   # Segment number zero
    movw %ax, %ds                                   # -> Data Segment
    movw %ax, %es                                   # -> Extra Segment
    movw %ax, %ss                                   # -> Stack Segment
```

（1）进入正式工作，第一步是开启A20。参考[附录](https://objectkuan.gitbooks.io/ucore-docs/content/lab1/lab1_appendix_a20.html)中的介绍理解这一过程。首先，不断从```0x64```端口读状态寄存器的值，检查其中的bit 1，即输入寄存器的标志位。当该位为0时跳出循环：

```
seta20.1:
    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
    testb $0x2, %al
    jnz seta20.1
```

此时，我们可以输入写P2的命令了。这一命令通过```0x64```写入：

```
    movb $0xd1, %al                                 # 0xd1 -> port 0x64
    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
```

然后，再次等待输入端口空闲：

```
seta20.2:
    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
    testb $0x2, %al
    jnz seta20.2
```

空闲后跳出循环，向```0x60```端口写入P2的值。其中bit 1已经被置为1了，表示打开A20。

```
    movb $0xdf, %al                                 # 0xdf -> port 0x60
    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
```

（2）第二步为加载GDT。只需要一个简单的命令：

```lgdt gdtdesc```

我中，```gdtdesc```的定义也在```bootasm.S```中：

```
.p2align 2                                          # force 4 byte alignment
gdt:
    SEG_NULLASM                                     # null seg
    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel

gdtdesc:
    .word 0x17                                      # sizeof(gdt) - 1
    .long gdt                                       # address gdt
```

这是一个简单的描述符表，已经存在了数据区中。

（3）第三步为进入保护模式。即把```$CR0```寄存器中，标志保护模式的位置1即可。

```
    movl %cr0, %eax
    orl $CR0_PE_ON, %eax
    movl %eax, %cr0
```

之后就可以跳到保护模式的代码段了。通过```ljump```命令，同时修改了```$CS```的值。

（4）进入32位保护模式后，首先设置段寄存器的值：

```
.code32                                             # Assemble for 32-bit mode
protcseg:
    # Set up the protected-mode data segment registers
    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector
    movw %ax, %ds                                   # -> DS: Data Segment
    movw %ax, %es                                   # -> ES: Extra Segment
    movw %ax, %fs                                   # -> FS
    movw %ax, %gs                                   # -> GS
    movw %ax, %ss                                   # -> SS: Stack Segment
```

然后，设置堆栈相关寄存器的值建立堆栈：对战区是0到```0x7c00```，即```start```。

```
    movl $0x0, %ebp
    movl $start, %esp
```

最后，跳转进入boot主方法，后者使用C实现。

```
    call bootmain
```

##练习四
#####0、本练习中涉及到的原理课中的知识点

##练习五
#####0、本练习中涉及到的原理课中的知识点

##练习六
#####0、本练习中涉及到的原理课中的知识点

